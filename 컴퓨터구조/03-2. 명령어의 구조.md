# 03-2. 명령어의 구조

> [혼자 공부하는 컴퓨터구조 + 운영체제] 책.
>
> Chapter 03. 명령어

하나의 명령어를 자세히 들여다보며 연산 코드, 오퍼랜드, 주소 지정 방식이라는 개념을 학습한다.

## 연산코드와 오퍼랜드

명령어는 `무엇을 대상으로, 어떤 작동을 수행하라`는 구조로 되어 있다.

더 자세히 이야기 하면, 명령어는 `명령의 작동(연산)`과 `연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치`를 담고 있다. 이 각각을 연산코드와 오퍼랜드라고 한다.

**연산코드 (operation code)** : 명령어가 수행할 연산. 연산자.

**오퍼랜드 (operand)** : 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치. 피연산자.

**연산 코드 필드** : 연산코드가 담기는 영역

**오퍼랜드 필드** : 오퍼랜드가 담기는 영역

```
// 어셈블리어 예시
연산코드	오퍼랜드
push	  rbp
mov		  rbp, rsp
mov		  DWORD PTR [rbp-4], 1
mov		  DWORD PTR [rbp-8], 2
mov		  edx, DWORD PTR [rbp-4]
```

### 오퍼랜드

오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다. 그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도 한다.

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한개만 있을 수도 있고, 두 개 또는 세 개 등 여러 개가 있을 수도 있다.

오퍼랜드가 n개 인 경우, 해당 명령어는 **n-주소 명령어**라고 한다.

### 연산코드

연산코드의 종류는 매우 많지만, 가장 기본적인 연산코드 유형은 크게 4가지로 나눌 수 있다.

```
1) 데이터 전송
- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 저장하라
2) 산술/논리 연산
- ADD / SUBSTRACT / MULTIPLY / DIVIDE : + / - / × / ÷ 을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- AND / OR / NOT : AND / OR / NOT 연산을 수행하라
- COMPARE : 두개의 숫자 or TRUE / FALSE 값을 비교하라
3) 제어 흐름 변경
- JUMP : 특정 주소로 실행순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
4) 입출력 제어
- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라
```



## 주소 지정 방식

명령어의 오퍼랜드 필드에 주소를 지정하지 않고 연산에 사용될 데이터를 직접 넣게 되는 경우, 오퍼랜드 필드에 할당된 공간만큼만 표현할 수 있다.

가령 명령어의 크기가 16비트, 연산코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드 당 6비트 밖에 되지 않고, 하나의 오퍼랜드 필드로 표현할 수 있는 정보는 2⁶개 밖에 되지 않는다.

하지만 만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면, 표현할 수 있는 데이터 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.

오퍼랜드 필드에 메모리 주소가 아닌 레지스터 이름을 명시할 때도 마찬가지로, 해당 레지스터가 저장할 수 있는 공간만큼 표현 가능한 정보의 가짓수가 커진다.

**유효 주소 (effective address)** : 연산의 대상이 되는 데이터가 저장된 위치

**주소 지정 방식 (addressing mode)** : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법. 즉, 유효 주소를 찾는 방법. 현대 CPU는 다양한 주소 지정 방식을 사용하는데 그 중 대표적인 몇가지를 알아보자.

### 즉시 주소 지정 방식

연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식. 표현 가능한 데이터의 크기가 작아지는 단점이 있지만 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 주소 지정 방식들보다 빠르다.

### 직접 주소 지정 방식

오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식. 즉시 주소 지정 방식보다 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 더 커졌지만, 연산 코드의 길이만큼 오퍼랜드 필드의 길이가 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

### 간접 주소 지정 방식

유효 주소의 주소를 오퍼랜드 필드에 명시. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어졌지만, 두번의 메모리 접근이 필요하기 때문에 앞서 설명한 주소 지정 방식들보다 일반적으로는 느린 방식.

### 레지스터 주소 지정 방식

직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법. 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르기 때문에 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다.

### 레지스터 간접 주소 지정 방식

연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법. 간접 주소 지정 방식과 과정이 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다는 장점이 있다. 그래서 간접 주소 지정 방식보다 빠르다.